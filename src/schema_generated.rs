// automatically generated by the FlatBuffers compiler, do not modify

// @generated

//this allow is not generated, just tells rust clippy to shut up
#![allow(
    unused_imports,
    dead_code,
    clippy::extra_unused_lifetimes,
    clippy::derivable_impls,
    clippy::needless_lifetimes
)]

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_REQUEST: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_REQUEST: u8 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_REQUEST: [Request; 5] = [
    Request::NONE,
    Request::TryPutData,
    Request::TryGetData,
    Request::TryDeleteData,
    Request::TryRefreshData,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Request(pub u8);
#[allow(non_upper_case_globals)]
impl Request {
    pub const NONE: Self = Self(0);
    pub const TryPutData: Self = Self(1);
    pub const TryGetData: Self = Self(2);
    pub const TryDeleteData: Self = Self(3);
    pub const TryRefreshData: Self = Self(4);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::TryPutData,
        Self::TryGetData,
        Self::TryDeleteData,
        Self::TryRefreshData,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::TryPutData => Some("TryPutData"),
            Self::TryGetData => Some("TryGetData"),
            Self::TryDeleteData => Some("TryDeleteData"),
            Self::TryRefreshData => Some("TryRefreshData"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for Request {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for Request {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for Request {
    type Output = Request;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Request {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for Request {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Request {}
pub struct RequestUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_RESPONSE: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_RESPONSE: u8 = 4;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_RESPONSE: [Response; 5] = [
    Response::NONE,
    Response::ErrResp,
    Response::PutDataResp,
    Response::GetDataResp,
    Response::DelDataResp,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Response(pub u8);
#[allow(non_upper_case_globals)]
impl Response {
    pub const NONE: Self = Self(0);
    pub const ErrResp: Self = Self(1);
    pub const PutDataResp: Self = Self(2);
    pub const GetDataResp: Self = Self(3);
    pub const DelDataResp: Self = Self(4);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 4;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::ErrResp,
        Self::PutDataResp,
        Self::GetDataResp,
        Self::DelDataResp,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::ErrResp => Some("ErrResp"),
            Self::PutDataResp => Some("PutDataResp"),
            Self::GetDataResp => Some("GetDataResp"),
            Self::DelDataResp => Some("DelDataResp"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for Response {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for Response {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for Response {
    type Output = Response;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Response {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for Response {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for Response {}
pub struct ResponseUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_DIRECTIONAL_PACKET: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_DIRECTIONAL_PACKET: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DIRECTIONAL_PACKET: [DirectionalPacket; 3] = [
    DirectionalPacket::NONE,
    DirectionalPacket::C2SRequests,
    DirectionalPacket::S2CResponses,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DirectionalPacket(pub u8);
#[allow(non_upper_case_globals)]
impl DirectionalPacket {
    pub const NONE: Self = Self(0);
    pub const C2SRequests: Self = Self(1);
    pub const S2CResponses: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::C2SRequests, Self::S2CResponses];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::C2SRequests => Some("C2SRequests"),
            Self::S2CResponses => Some("S2CResponses"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for DirectionalPacket {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for DirectionalPacket {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for DirectionalPacket {
    type Output = DirectionalPacket;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for DirectionalPacket {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for DirectionalPacket {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for DirectionalPacket {}
pub struct DirectionalPacketUnionTableOffset {}

// struct IotaControllKey, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct IotaControllKey(pub [u8; 255]);
impl Default for IotaControllKey {
    fn default() -> Self {
        Self([0; 255])
    }
}
impl core::fmt::Debug for IotaControllKey {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IotaControllKey")
            .field("key", &self.key())
            .finish()
    }
}

impl flatbuffers::SimpleToVerifyInSlice for IotaControllKey {}
impl<'a> flatbuffers::Follow<'a> for IotaControllKey {
    type Inner = &'a IotaControllKey;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        <&'a IotaControllKey>::follow(buf, loc)
    }
}
impl<'a> flatbuffers::Follow<'a> for &'a IotaControllKey {
    type Inner = &'a IotaControllKey;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        flatbuffers::follow_cast_ref::<IotaControllKey>(buf, loc)
    }
}
impl<'b> flatbuffers::Push for IotaControllKey {
    type Output = IotaControllKey;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = ::core::slice::from_raw_parts(
            self as *const IotaControllKey as *const u8,
            Self::size(),
        );
        dst.copy_from_slice(src);
    }
}

impl<'a> flatbuffers::Verifiable for IotaControllKey {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.in_buffer::<Self>(pos)
    }
}

impl<'a> IotaControllKey {
    #[allow(clippy::too_many_arguments)]
    pub fn new(key: &[i8; 255]) -> Self {
        let mut s = Self([0; 255]);
        s.set_key(key);
        s
    }

    pub fn key(&'a self) -> flatbuffers::Array<'a, i8, 255> {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid array in this slot
        unsafe { flatbuffers::Array::follow(&self.0, 0) }
    }

    pub fn set_key(&mut self, items: &[i8; 255]) {
        // Safety:
        // Created from a valid Table for this object
        // Which contains a valid array in this slot
        unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
    }
}

pub enum TryPutDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TryPutData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TryPutData<'a> {
    type Inner = TryPutData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TryPutData<'a> {
    pub const VT_PATTERN: flatbuffers::VOffsetT = 4;
    pub const VT_NBT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TryPutData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TryPutDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<TryPutData<'bldr>> {
        let mut builder = TryPutDataBuilder::new(_fbb);
        if let Some(x) = args.nbt {
            builder.add_nbt(x);
        }
        if let Some(x) = args.pattern {
            builder.add_pattern(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn pattern(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TryPutData::VT_PATTERN, None)
        }
    }
    #[inline]
    pub fn nbt(&self) -> Option<flatbuffers::Vector<'a, i8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(
                    TryPutData::VT_NBT,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for TryPutData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pattern", Self::VT_PATTERN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(
                "nbt",
                Self::VT_NBT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct TryPutDataArgs<'a> {
    pub pattern: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nbt: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for TryPutDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        TryPutDataArgs {
            pattern: None,
            nbt: None,
        }
    }
}

pub struct TryPutDataBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TryPutDataBuilder<'a, 'b> {
    #[inline]
    pub fn add_pattern(&mut self, pattern: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TryPutData::VT_PATTERN, pattern);
    }
    #[inline]
    pub fn add_nbt(&mut self, nbt: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TryPutData::VT_NBT, nbt);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TryPutDataBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TryPutDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TryPutData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TryPutData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TryPutData");
        ds.field("pattern", &self.pattern());
        ds.field("nbt", &self.nbt());
        ds.finish()
    }
}
pub enum TryGetDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TryGetData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TryGetData<'a> {
    type Inner = TryGetData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TryGetData<'a> {
    pub const VT_PATTERN: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TryGetData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TryGetDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<TryGetData<'bldr>> {
        let mut builder = TryGetDataBuilder::new(_fbb);
        if let Some(x) = args.pattern {
            builder.add_pattern(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn pattern(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TryGetData::VT_PATTERN, None)
        }
    }
}

impl flatbuffers::Verifiable for TryGetData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pattern", Self::VT_PATTERN, false)?
            .finish();
        Ok(())
    }
}
pub struct TryGetDataArgs<'a> {
    pub pattern: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for TryGetDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        TryGetDataArgs { pattern: None }
    }
}

pub struct TryGetDataBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TryGetDataBuilder<'a, 'b> {
    #[inline]
    pub fn add_pattern(&mut self, pattern: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TryGetData::VT_PATTERN, pattern);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TryGetDataBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TryGetDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TryGetData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TryGetData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TryGetData");
        ds.field("pattern", &self.pattern());
        ds.finish()
    }
}
pub enum TryDeleteDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TryDeleteData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TryDeleteData<'a> {
    type Inner = TryDeleteData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TryDeleteData<'a> {
    pub const VT_PATTERN: flatbuffers::VOffsetT = 4;
    pub const VT_KEY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TryDeleteData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TryDeleteDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<TryDeleteData<'bldr>> {
        let mut builder = TryDeleteDataBuilder::new(_fbb);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        if let Some(x) = args.pattern {
            builder.add_pattern(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn pattern(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TryDeleteData::VT_PATTERN, None)
        }
    }
    #[inline]
    pub fn key(&self) -> Option<&'a IotaControllKey> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<IotaControllKey>(TryDeleteData::VT_KEY, None)
        }
    }
}

impl flatbuffers::Verifiable for TryDeleteData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pattern", Self::VT_PATTERN, false)?
            .visit_field::<IotaControllKey>("key", Self::VT_KEY, false)?
            .finish();
        Ok(())
    }
}
pub struct TryDeleteDataArgs<'a> {
    pub pattern: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<&'a IotaControllKey>,
}
impl<'a> Default for TryDeleteDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        TryDeleteDataArgs {
            pattern: None,
            key: None,
        }
    }
}

pub struct TryDeleteDataBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TryDeleteDataBuilder<'a, 'b> {
    #[inline]
    pub fn add_pattern(&mut self, pattern: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TryDeleteData::VT_PATTERN, pattern);
    }
    #[inline]
    pub fn add_key(&mut self, key: &IotaControllKey) {
        self.fbb_
            .push_slot_always::<&IotaControllKey>(TryDeleteData::VT_KEY, key);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TryDeleteDataBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TryDeleteDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TryDeleteData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TryDeleteData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TryDeleteData");
        ds.field("pattern", &self.pattern());
        ds.field("key", &self.key());
        ds.finish()
    }
}
pub enum TryRefreshDataOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct TryRefreshData<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for TryRefreshData<'a> {
    type Inner = TryRefreshData<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> TryRefreshData<'a> {
    pub const VT_PATTERN: flatbuffers::VOffsetT = 4;
    pub const VT_KEY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        TryRefreshData { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args TryRefreshDataArgs<'args>,
    ) -> flatbuffers::WIPOffset<TryRefreshData<'bldr>> {
        let mut builder = TryRefreshDataBuilder::new(_fbb);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        if let Some(x) = args.pattern {
            builder.add_pattern(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn pattern(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(TryRefreshData::VT_PATTERN, None)
        }
    }
    #[inline]
    pub fn key(&self) -> Option<&'a IotaControllKey> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<IotaControllKey>(TryRefreshData::VT_KEY, None)
        }
    }
}

impl flatbuffers::Verifiable for TryRefreshData<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pattern", Self::VT_PATTERN, false)?
            .visit_field::<IotaControllKey>("key", Self::VT_KEY, false)?
            .finish();
        Ok(())
    }
}
pub struct TryRefreshDataArgs<'a> {
    pub pattern: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<&'a IotaControllKey>,
}
impl<'a> Default for TryRefreshDataArgs<'a> {
    #[inline]
    fn default() -> Self {
        TryRefreshDataArgs {
            pattern: None,
            key: None,
        }
    }
}

pub struct TryRefreshDataBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> TryRefreshDataBuilder<'a, 'b> {
    #[inline]
    pub fn add_pattern(&mut self, pattern: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(TryRefreshData::VT_PATTERN, pattern);
    }
    #[inline]
    pub fn add_key(&mut self, key: &IotaControllKey) {
        self.fbb_
            .push_slot_always::<&IotaControllKey>(TryRefreshData::VT_KEY, key);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TryRefreshDataBuilder<'a, 'b> {
        let start = _fbb.start_table();
        TryRefreshDataBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<TryRefreshData<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for TryRefreshData<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("TryRefreshData");
        ds.field("pattern", &self.pattern());
        ds.field("key", &self.key());
        ds.finish()
    }
}
pub enum ReqWrapOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ReqWrap<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ReqWrap<'a> {
    type Inner = ReqWrap<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ReqWrap<'a> {
    pub const VT_VAL_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VAL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ReqWrap { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ReqWrapArgs,
    ) -> flatbuffers::WIPOffset<ReqWrap<'bldr>> {
        let mut builder = ReqWrapBuilder::new(_fbb);
        if let Some(x) = args.val {
            builder.add_val(x);
        }
        builder.add_val_type(args.val_type);
        builder.finish()
    }

    #[inline]
    pub fn val_type(&self) -> Request {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Request>(ReqWrap::VT_VAL_TYPE, Some(Request::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn val(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(ReqWrap::VT_VAL, None)
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn val_as_try_put_data(&self) -> Option<TryPutData<'a>> {
        if self.val_type() == Request::TryPutData {
            self.val().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TryPutData::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn val_as_try_get_data(&self) -> Option<TryGetData<'a>> {
        if self.val_type() == Request::TryGetData {
            self.val().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TryGetData::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn val_as_try_delete_data(&self) -> Option<TryDeleteData<'a>> {
        if self.val_type() == Request::TryDeleteData {
            self.val().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TryDeleteData::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn val_as_try_refresh_data(&self) -> Option<TryRefreshData<'a>> {
        if self.val_type() == Request::TryRefreshData {
            self.val().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { TryRefreshData::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for ReqWrap<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<Request, _>(
                "val_type",
                Self::VT_VAL_TYPE,
                "val",
                Self::VT_VAL,
                false,
                |key, v, pos| match key {
                    Request::TryPutData => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<TryPutData>>(
                            "Request::TryPutData",
                            pos,
                        ),
                    Request::TryGetData => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<TryGetData>>(
                            "Request::TryGetData",
                            pos,
                        ),
                    Request::TryDeleteData => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<TryDeleteData>>(
                            "Request::TryDeleteData",
                            pos,
                        ),
                    Request::TryRefreshData => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<TryRefreshData>>(
                            "Request::TryRefreshData",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct ReqWrapArgs {
    pub val_type: Request,
    pub val: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ReqWrapArgs {
    #[inline]
    fn default() -> Self {
        ReqWrapArgs {
            val_type: Request::NONE,
            val: None,
        }
    }
}

pub struct ReqWrapBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ReqWrapBuilder<'a, 'b> {
    #[inline]
    pub fn add_val_type(&mut self, val_type: Request) {
        self.fbb_
            .push_slot::<Request>(ReqWrap::VT_VAL_TYPE, val_type, Request::NONE);
    }
    #[inline]
    pub fn add_val(&mut self, val: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ReqWrap::VT_VAL, val);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ReqWrapBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ReqWrapBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ReqWrap<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ReqWrap<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ReqWrap");
        ds.field("val_type", &self.val_type());
        match self.val_type() {
            Request::TryPutData => {
                if let Some(x) = self.val_as_try_put_data() {
                    ds.field("val", &x)
                } else {
                    ds.field(
                        "val",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            Request::TryGetData => {
                if let Some(x) = self.val_as_try_get_data() {
                    ds.field("val", &x)
                } else {
                    ds.field(
                        "val",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            Request::TryDeleteData => {
                if let Some(x) = self.val_as_try_delete_data() {
                    ds.field("val", &x)
                } else {
                    ds.field(
                        "val",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            Request::TryRefreshData => {
                if let Some(x) = self.val_as_try_refresh_data() {
                    ds.field("val", &x)
                } else {
                    ds.field(
                        "val",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("val", &x)
            }
        };
        ds.finish()
    }
}
pub enum C2SRequestsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct C2SRequests<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for C2SRequests<'a> {
    type Inner = C2SRequests<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> C2SRequests<'a> {
    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_PACKETS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        C2SRequests { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args C2SRequestsArgs<'args>,
    ) -> flatbuffers::WIPOffset<C2SRequests<'bldr>> {
        let mut builder = C2SRequestsBuilder::new(_fbb);
        if let Some(x) = args.packets {
            builder.add_packets(x);
        }
        builder.add_version(args.version);
        builder.finish()
    }

    #[inline]
    pub fn version(&self) -> i16 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i16>(C2SRequests::VT_VERSION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn packets(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ReqWrap<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ReqWrap>>,
            >>(C2SRequests::VT_PACKETS, None)
        }
    }
}

impl flatbuffers::Verifiable for C2SRequests<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i16>("version", Self::VT_VERSION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ReqWrap>>,
            >>("packets", Self::VT_PACKETS, false)?
            .finish();
        Ok(())
    }
}
pub struct C2SRequestsArgs<'a> {
    pub version: i16,
    pub packets: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ReqWrap<'a>>>>,
    >,
}
impl<'a> Default for C2SRequestsArgs<'a> {
    #[inline]
    fn default() -> Self {
        C2SRequestsArgs {
            version: 0,
            packets: None,
        }
    }
}

pub struct C2SRequestsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> C2SRequestsBuilder<'a, 'b> {
    #[inline]
    pub fn add_version(&mut self, version: i16) {
        self.fbb_
            .push_slot::<i16>(C2SRequests::VT_VERSION, version, 0);
    }
    #[inline]
    pub fn add_packets(
        &mut self,
        packets: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<ReqWrap<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(C2SRequests::VT_PACKETS, packets);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> C2SRequestsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        C2SRequestsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<C2SRequests<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for C2SRequests<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("C2SRequests");
        ds.field("version", &self.version());
        ds.field("packets", &self.packets());
        ds.finish()
    }
}
pub enum PutDataRespOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PutDataResp<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PutDataResp<'a> {
    type Inner = PutDataResp<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> PutDataResp<'a> {
    pub const VT_PATTERN: flatbuffers::VOffsetT = 4;
    pub const VT_KEY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        PutDataResp { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args PutDataRespArgs<'args>,
    ) -> flatbuffers::WIPOffset<PutDataResp<'bldr>> {
        let mut builder = PutDataRespBuilder::new(_fbb);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        if let Some(x) = args.pattern {
            builder.add_pattern(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn pattern(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(PutDataResp::VT_PATTERN, None)
        }
    }
    #[inline]
    pub fn key(&self) -> Option<&'a IotaControllKey> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<IotaControllKey>(PutDataResp::VT_KEY, None) }
    }
}

impl flatbuffers::Verifiable for PutDataResp<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pattern", Self::VT_PATTERN, false)?
            .visit_field::<IotaControllKey>("key", Self::VT_KEY, false)?
            .finish();
        Ok(())
    }
}
pub struct PutDataRespArgs<'a> {
    pub pattern: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<&'a IotaControllKey>,
}
impl<'a> Default for PutDataRespArgs<'a> {
    #[inline]
    fn default() -> Self {
        PutDataRespArgs {
            pattern: None,
            key: None,
        }
    }
}

pub struct PutDataRespBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> PutDataRespBuilder<'a, 'b> {
    #[inline]
    pub fn add_pattern(&mut self, pattern: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(PutDataResp::VT_PATTERN, pattern);
    }
    #[inline]
    pub fn add_key(&mut self, key: &IotaControllKey) {
        self.fbb_
            .push_slot_always::<&IotaControllKey>(PutDataResp::VT_KEY, key);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> PutDataRespBuilder<'a, 'b> {
        let start = _fbb.start_table();
        PutDataRespBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<PutDataResp<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for PutDataResp<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("PutDataResp");
        ds.field("pattern", &self.pattern());
        ds.field("key", &self.key());
        ds.finish()
    }
}
pub enum GetDataRespOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetDataResp<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetDataResp<'a> {
    type Inner = GetDataResp<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> GetDataResp<'a> {
    pub const VT_PATTERN: flatbuffers::VOffsetT = 4;
    pub const VT_NBT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GetDataResp { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GetDataRespArgs<'args>,
    ) -> flatbuffers::WIPOffset<GetDataResp<'bldr>> {
        let mut builder = GetDataRespBuilder::new(_fbb);
        if let Some(x) = args.nbt {
            builder.add_nbt(x);
        }
        if let Some(x) = args.pattern {
            builder.add_pattern(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn pattern(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(GetDataResp::VT_PATTERN, None)
        }
    }
    #[inline]
    pub fn nbt(&self) -> Option<flatbuffers::Vector<'a, i8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(
                    GetDataResp::VT_NBT,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for GetDataResp<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pattern", Self::VT_PATTERN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(
                "nbt",
                Self::VT_NBT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct GetDataRespArgs<'a> {
    pub pattern: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nbt: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for GetDataRespArgs<'a> {
    #[inline]
    fn default() -> Self {
        GetDataRespArgs {
            pattern: None,
            nbt: None,
        }
    }
}

pub struct GetDataRespBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GetDataRespBuilder<'a, 'b> {
    #[inline]
    pub fn add_pattern(&mut self, pattern: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(GetDataResp::VT_PATTERN, pattern);
    }
    #[inline]
    pub fn add_nbt(&mut self, nbt: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(GetDataResp::VT_NBT, nbt);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GetDataRespBuilder<'a, 'b> {
        let start = _fbb.start_table();
        GetDataRespBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<GetDataResp<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for GetDataResp<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("GetDataResp");
        ds.field("pattern", &self.pattern());
        ds.field("nbt", &self.nbt());
        ds.finish()
    }
}
pub enum DelDataRespOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct DelDataResp<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for DelDataResp<'a> {
    type Inner = DelDataResp<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> DelDataResp<'a> {
    pub const VT_PATTERN: flatbuffers::VOffsetT = 4;
    pub const VT_NBT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        DelDataResp { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args DelDataRespArgs<'args>,
    ) -> flatbuffers::WIPOffset<DelDataResp<'bldr>> {
        let mut builder = DelDataRespBuilder::new(_fbb);
        if let Some(x) = args.nbt {
            builder.add_nbt(x);
        }
        if let Some(x) = args.pattern {
            builder.add_pattern(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn pattern(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(DelDataResp::VT_PATTERN, None)
        }
    }
    #[inline]
    pub fn nbt(&self) -> Option<flatbuffers::Vector<'a, i8>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(
                    DelDataResp::VT_NBT,
                    None,
                )
        }
    }
}

impl flatbuffers::Verifiable for DelDataResp<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pattern", Self::VT_PATTERN, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(
                "nbt",
                Self::VT_NBT,
                false,
            )?
            .finish();
        Ok(())
    }
}
pub struct DelDataRespArgs<'a> {
    pub pattern: Option<flatbuffers::WIPOffset<&'a str>>,
    pub nbt: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for DelDataRespArgs<'a> {
    #[inline]
    fn default() -> Self {
        DelDataRespArgs {
            pattern: None,
            nbt: None,
        }
    }
}

pub struct DelDataRespBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> DelDataRespBuilder<'a, 'b> {
    #[inline]
    pub fn add_pattern(&mut self, pattern: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DelDataResp::VT_PATTERN, pattern);
    }
    #[inline]
    pub fn add_nbt(&mut self, nbt: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(DelDataResp::VT_NBT, nbt);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DelDataRespBuilder<'a, 'b> {
        let start = _fbb.start_table();
        DelDataRespBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<DelDataResp<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for DelDataResp<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("DelDataResp");
        ds.field("pattern", &self.pattern());
        ds.field("nbt", &self.nbt());
        ds.finish()
    }
}
pub enum RefreshDataRespOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RefreshDataResp<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RefreshDataResp<'a> {
    type Inner = RefreshDataResp<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RefreshDataResp<'a> {
    pub const VT_PATTERN: flatbuffers::VOffsetT = 4;
    pub const VT_KEY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RefreshDataResp { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RefreshDataRespArgs<'args>,
    ) -> flatbuffers::WIPOffset<RefreshDataResp<'bldr>> {
        let mut builder = RefreshDataRespBuilder::new(_fbb);
        if let Some(x) = args.key {
            builder.add_key(x);
        }
        if let Some(x) = args.pattern {
            builder.add_pattern(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn pattern(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(RefreshDataResp::VT_PATTERN, None)
        }
    }
    #[inline]
    pub fn key(&self) -> Option<&'a IotaControllKey> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<IotaControllKey>(RefreshDataResp::VT_KEY, None)
        }
    }
}

impl flatbuffers::Verifiable for RefreshDataResp<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("pattern", Self::VT_PATTERN, false)?
            .visit_field::<IotaControllKey>("key", Self::VT_KEY, false)?
            .finish();
        Ok(())
    }
}
pub struct RefreshDataRespArgs<'a> {
    pub pattern: Option<flatbuffers::WIPOffset<&'a str>>,
    pub key: Option<&'a IotaControllKey>,
}
impl<'a> Default for RefreshDataRespArgs<'a> {
    #[inline]
    fn default() -> Self {
        RefreshDataRespArgs {
            pattern: None,
            key: None,
        }
    }
}

pub struct RefreshDataRespBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RefreshDataRespBuilder<'a, 'b> {
    #[inline]
    pub fn add_pattern(&mut self, pattern: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RefreshDataResp::VT_PATTERN, pattern);
    }
    #[inline]
    pub fn add_key(&mut self, key: &IotaControllKey) {
        self.fbb_
            .push_slot_always::<&IotaControllKey>(RefreshDataResp::VT_KEY, key);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RefreshDataRespBuilder<'a, 'b> {
        let start = _fbb.start_table();
        RefreshDataRespBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RefreshDataResp<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RefreshDataResp<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RefreshDataResp");
        ds.field("pattern", &self.pattern());
        ds.field("key", &self.key());
        ds.finish()
    }
}
pub enum ErrRespOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ErrResp<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ErrResp<'a> {
    type Inner = ErrResp<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> ErrResp<'a> {
    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OTHER: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        ErrResp { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args ErrRespArgs<'args>,
    ) -> flatbuffers::WIPOffset<ErrResp<'bldr>> {
        let mut builder = ErrRespBuilder::new(_fbb);
        if let Some(x) = args.other {
            builder.add_other(x);
        }
        builder.add_id(args.id);
        builder.finish()
    }

    #[inline]
    pub fn id(&self) -> u16 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u16>(ErrResp::VT_ID, Some(0)).unwrap() }
    }
    #[inline]
    pub fn other(&self) -> Option<&'a str> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(ErrResp::VT_OTHER, None)
        }
    }
}

impl flatbuffers::Verifiable for ErrResp<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u16>("id", Self::VT_ID, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("other", Self::VT_OTHER, false)?
            .finish();
        Ok(())
    }
}
pub struct ErrRespArgs<'a> {
    pub id: u16,
    pub other: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ErrRespArgs<'a> {
    #[inline]
    fn default() -> Self {
        ErrRespArgs { id: 0, other: None }
    }
}

pub struct ErrRespBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> ErrRespBuilder<'a, 'b> {
    #[inline]
    pub fn add_id(&mut self, id: u16) {
        self.fbb_.push_slot::<u16>(ErrResp::VT_ID, id, 0);
    }
    #[inline]
    pub fn add_other(&mut self, other: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(ErrResp::VT_OTHER, other);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ErrRespBuilder<'a, 'b> {
        let start = _fbb.start_table();
        ErrRespBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<ErrResp<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for ErrResp<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("ErrResp");
        ds.field("id", &self.id());
        ds.field("other", &self.other());
        ds.finish()
    }
}
pub enum RWrapOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RWrap<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for RWrap<'a> {
    type Inner = RWrap<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> RWrap<'a> {
    pub const VT_VAL_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VAL: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        RWrap { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RWrapArgs,
    ) -> flatbuffers::WIPOffset<RWrap<'bldr>> {
        let mut builder = RWrapBuilder::new(_fbb);
        if let Some(x) = args.val {
            builder.add_val(x);
        }
        builder.add_val_type(args.val_type);
        builder.finish()
    }

    #[inline]
    pub fn val_type(&self) -> Response {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<Response>(RWrap::VT_VAL_TYPE, Some(Response::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn val(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(RWrap::VT_VAL, None)
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn val_as_err_resp(&self) -> Option<ErrResp<'a>> {
        if self.val_type() == Response::ErrResp {
            self.val().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { ErrResp::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn val_as_put_data_resp(&self) -> Option<PutDataResp<'a>> {
        if self.val_type() == Response::PutDataResp {
            self.val().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { PutDataResp::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn val_as_get_data_resp(&self) -> Option<GetDataResp<'a>> {
        if self.val_type() == Response::GetDataResp {
            self.val().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { GetDataResp::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn val_as_del_data_resp(&self) -> Option<DelDataResp<'a>> {
        if self.val_type() == Response::DelDataResp {
            self.val().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { DelDataResp::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for RWrap<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<Response, _>(
                "val_type",
                Self::VT_VAL_TYPE,
                "val",
                Self::VT_VAL,
                false,
                |key, v, pos| match key {
                    Response::ErrResp => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<ErrResp>>(
                            "Response::ErrResp",
                            pos,
                        ),
                    Response::PutDataResp => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<PutDataResp>>(
                            "Response::PutDataResp",
                            pos,
                        ),
                    Response::GetDataResp => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<GetDataResp>>(
                            "Response::GetDataResp",
                            pos,
                        ),
                    Response::DelDataResp => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<DelDataResp>>(
                            "Response::DelDataResp",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct RWrapArgs {
    pub val_type: Response,
    pub val: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RWrapArgs {
    #[inline]
    fn default() -> Self {
        RWrapArgs {
            val_type: Response::NONE,
            val: None,
        }
    }
}

pub struct RWrapBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RWrapBuilder<'a, 'b> {
    #[inline]
    pub fn add_val_type(&mut self, val_type: Response) {
        self.fbb_
            .push_slot::<Response>(RWrap::VT_VAL_TYPE, val_type, Response::NONE);
    }
    #[inline]
    pub fn add_val(&mut self, val: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(RWrap::VT_VAL, val);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RWrapBuilder<'a, 'b> {
        let start = _fbb.start_table();
        RWrapBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<RWrap<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for RWrap<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("RWrap");
        ds.field("val_type", &self.val_type());
        match self.val_type() {
            Response::ErrResp => {
                if let Some(x) = self.val_as_err_resp() {
                    ds.field("val", &x)
                } else {
                    ds.field(
                        "val",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            Response::PutDataResp => {
                if let Some(x) = self.val_as_put_data_resp() {
                    ds.field("val", &x)
                } else {
                    ds.field(
                        "val",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            Response::GetDataResp => {
                if let Some(x) = self.val_as_get_data_resp() {
                    ds.field("val", &x)
                } else {
                    ds.field(
                        "val",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            Response::DelDataResp => {
                if let Some(x) = self.val_as_del_data_resp() {
                    ds.field("val", &x)
                } else {
                    ds.field(
                        "val",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("val", &x)
            }
        };
        ds.finish()
    }
}
pub enum S2CResponsesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct S2CResponses<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for S2CResponses<'a> {
    type Inner = S2CResponses<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> S2CResponses<'a> {
    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_PACKETS: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        S2CResponses { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args S2CResponsesArgs<'args>,
    ) -> flatbuffers::WIPOffset<S2CResponses<'bldr>> {
        let mut builder = S2CResponsesBuilder::new(_fbb);
        if let Some(x) = args.packets {
            builder.add_packets(x);
        }
        builder.add_version(args.version);
        builder.finish()
    }

    #[inline]
    pub fn version(&self) -> i16 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<i16>(S2CResponses::VT_VERSION, Some(0))
                .unwrap()
        }
    }
    #[inline]
    pub fn packets(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RWrap<'a>>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab.get::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RWrap>>,
            >>(S2CResponses::VT_PACKETS, None)
        }
    }
}

impl flatbuffers::Verifiable for S2CResponses<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i16>("version", Self::VT_VERSION, false)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<RWrap>>,
            >>("packets", Self::VT_PACKETS, false)?
            .finish();
        Ok(())
    }
}
pub struct S2CResponsesArgs<'a> {
    pub version: i16,
    pub packets: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<RWrap<'a>>>>,
    >,
}
impl<'a> Default for S2CResponsesArgs<'a> {
    #[inline]
    fn default() -> Self {
        S2CResponsesArgs {
            version: 0,
            packets: None,
        }
    }
}

pub struct S2CResponsesBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> S2CResponsesBuilder<'a, 'b> {
    #[inline]
    pub fn add_version(&mut self, version: i16) {
        self.fbb_
            .push_slot::<i16>(S2CResponses::VT_VERSION, version, 0);
    }
    #[inline]
    pub fn add_packets(
        &mut self,
        packets: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<RWrap<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(S2CResponses::VT_PACKETS, packets);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> S2CResponsesBuilder<'a, 'b> {
        let start = _fbb.start_table();
        S2CResponsesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<S2CResponses<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for S2CResponses<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("S2CResponses");
        ds.field("version", &self.version());
        ds.field("packets", &self.packets());
        ds.finish()
    }
}
pub enum BaseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Base<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Base<'a> {
    type Inner = Base<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Base<'a> {
    pub const VT_CONTENT_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_CONTENT: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Base { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BaseArgs,
    ) -> flatbuffers::WIPOffset<Base<'bldr>> {
        let mut builder = BaseBuilder::new(_fbb);
        if let Some(x) = args.content {
            builder.add_content(x);
        }
        builder.add_content_type(args.content_type);
        builder.finish()
    }

    #[inline]
    pub fn content_type(&self) -> DirectionalPacket {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<DirectionalPacket>(Base::VT_CONTENT_TYPE, Some(DirectionalPacket::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn content(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Base::VT_CONTENT, None)
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn content_as_c2_srequests(&self) -> Option<C2SRequests<'a>> {
        if self.content_type() == DirectionalPacket::C2SRequests {
            self.content().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { C2SRequests::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn content_as_s2_cresponses(&self) -> Option<S2CResponses<'a>> {
        if self.content_type() == DirectionalPacket::S2CResponses {
            self.content().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { S2CResponses::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for Base<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<DirectionalPacket, _>(
                "content_type",
                Self::VT_CONTENT_TYPE,
                "content",
                Self::VT_CONTENT,
                false,
                |key, v, pos| match key {
                    DirectionalPacket::C2SRequests => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<C2SRequests>>(
                            "DirectionalPacket::C2SRequests",
                            pos,
                        ),
                    DirectionalPacket::S2CResponses => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<S2CResponses>>(
                            "DirectionalPacket::S2CResponses",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct BaseArgs {
    pub content_type: DirectionalPacket,
    pub content: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for BaseArgs {
    #[inline]
    fn default() -> Self {
        BaseArgs {
            content_type: DirectionalPacket::NONE,
            content: None,
        }
    }
}

pub struct BaseBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BaseBuilder<'a, 'b> {
    #[inline]
    pub fn add_content_type(&mut self, content_type: DirectionalPacket) {
        self.fbb_.push_slot::<DirectionalPacket>(
            Base::VT_CONTENT_TYPE,
            content_type,
            DirectionalPacket::NONE,
        );
    }
    #[inline]
    pub fn add_content(&mut self, content: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Base::VT_CONTENT, content);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BaseBuilder<'a, 'b> {
        let start = _fbb.start_table();
        BaseBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Base<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Base<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Base");
        ds.field("content_type", &self.content_type());
        match self.content_type() {
            DirectionalPacket::C2SRequests => {
                if let Some(x) = self.content_as_c2_srequests() {
                    ds.field("content", &x)
                } else {
                    ds.field(
                        "content",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            DirectionalPacket::S2CResponses => {
                if let Some(x) = self.content_as_s2_cresponses() {
                    ds.field("content", &x)
                } else {
                    ds.field(
                        "content",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("content", &x)
            }
        };
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Base`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_base_unchecked`.
pub fn root_as_base(buf: &[u8]) -> Result<Base, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<Base>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Base` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_base_unchecked`.
pub fn size_prefixed_root_as_base(buf: &[u8]) -> Result<Base, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<Base>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Base` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_base_unchecked`.
pub fn root_as_base_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Base<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<Base<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Base` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_base_unchecked`.
pub fn size_prefixed_root_as_base_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Base<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<Base<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Base and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Base`.
pub unsafe fn root_as_base_unchecked(buf: &[u8]) -> Base {
    flatbuffers::root_unchecked::<Base>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Base and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Base`.
pub unsafe fn size_prefixed_root_as_base_unchecked(buf: &[u8]) -> Base {
    flatbuffers::size_prefixed_root_unchecked::<Base>(buf)
}
#[inline]
pub fn finish_base_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Base<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_base_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Base<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
